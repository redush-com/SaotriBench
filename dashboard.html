<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SaotriBench — Live Dashboard</title>
<link rel="stylesheet" href="dashboard.css">
<link rel="icon" href="/favicon-32x32.png" type="image/png" sizes="32x32">
<link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>

<header>
  <h1><a href="https://saotri.com" class="home-link"><img src="/logo-32.png" alt="" width="32" height="32" class="logo">SaotriBench</a> — Live Dashboard</h1>
  <div class="status-bar">
    <div class="pulse-dot" id="statusDot"></div>
    <span id="statusText">Connecting...</span>
  </div>
</header>

<section id="summarySection">
  <h2>Completion Summary <span class="badge" id="summaryBadge">—</span>
    <span class="sort-controls">
      <button class="sort-btn active" data-sort="best" onclick="setSummarySort('best')">Best Results</button>
      <button class="sort-btn" data-sort="recent" onclick="setSummarySort('recent')">Most Recent</button>
    </span>
  </h2>
  <div id="summaryTable" class="loading">Loading...</div>
</section>

<section id="matrixSection">
  <h2>Pass / Fail Matrix <span class="badge" id="matrixBadge">latest run per model</span></h2>
  <div id="matrixTable" class="loading">Loading...</div>
</section>

<section id="difficultySection">
  <h2>By Difficulty <span class="badge" id="diffBadge">fully tested models</span></h2>
  <div id="difficultyTable" class="loading">Loading...</div>
</section>

<script>
const POLL_INTERVAL = 10_000;
let lastData = null;
let summarySort = 'best'; // 'best' | 'recent'

function setSummarySort(mode) {
  summarySort = mode;
  document.querySelectorAll('.sort-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.sort === mode);
  });
  if (lastData) renderSummary(lastData);
}

// ── Helpers ──────────────────────────────────────────────

function fmt(n, d = 1) {
  return Number(n).toFixed(d);
}

function fmtPct(n) {
  return (n * 100).toFixed(1) + '%';
}

function fmtDuration(s) {
  if (s < 60) return fmt(s, 0) + 's';
  if (s < 3600) return fmt(s / 60, 1) + 'm';
  return fmt(s / 3600, 1) + 'h';
}

function fmtTokens(n) {
  if (n >= 1_000_000) return fmt(n / 1_000_000, 1) + 'M';
  if (n >= 1_000) return fmt(n / 1_000, 1) + 'K';
  return String(n);
}

function diffClass(d) {
  return 'diff-' + (d || 'easy').toLowerCase();
}

function statusCell(run, totalPhases) {
  if (!run) return '<td class="cell-na">—</td>';
  const phases = run.phases_completed;
  const status = run.final_status;
  const label = `${phases}/${totalPhases}`;
  if (status === 'completed') return `<td class="cell-pass">PASS ${label}</td>`;
  if (status === 'error') return `<td class="cell-error">ERR ${label}</td>`;
  return `<td class="cell-fail">FAIL ${label}</td>`;
}

function progressBar(ratio) {
  const pct = Math.round(ratio * 100);
  let cls = 'green';
  if (ratio < 0.5) cls = 'red';
  else if (ratio < 0.8) cls = 'orange';
  return `<span class="progress-bar"><span class="progress-fill ${cls}" style="width:${pct}%"></span></span>`;
}

// ── Data Processing ──────────────────────────────────────

function buildLookup(data) {
  // { model -> { task_id -> run } }
  const lookup = {};
  for (const r of data.results) {
    const m = r.model_label;
    if (!lookup[m]) lookup[m] = {};
    lookup[m][r.task_id] = r;
  }
  return lookup;
}

function totalTaskCount(data) {
  return data.tasks.length;
}

// ── Render: Completion Summary ───────────────────────────

const DIFF_WEIGHT = { easy: 1, medium: 3, hard: 5 };

function renderSummary(data) {
  const lookup = buildLookup(data);
  const totalTasks = totalTaskCount(data);
  const totalPhasesAll = data.tasks.reduce((s, t) => s + t.total_phases, 0);

  const taskMap = {};
  for (const t of data.tasks) taskMap[t.task_id] = t;

  const maxWeightedScore = data.tasks.reduce((s, t) =>
    s + (DIFF_WEIGHT[(t.difficulty || 'easy').toLowerCase()] || 1), 0);

  const rows = [];
  for (const model of data.models) {
    const runs = lookup[model] || {};
    const tasksTested = Object.keys(runs).length;
    let tasksPassed = 0;
    let phasesCompleted = 0;
    let totalTokens = 0;
    let totalDuration = 0;
    let latestTimestamp = '';
    let weightedScore = 0;

    for (const r of Object.values(runs)) {
      if (r.final_status === 'completed') {
        tasksPassed++;
        const task = taskMap[r.task_id];
        weightedScore += DIFF_WEIGHT[(task?.difficulty || 'easy').toLowerCase()] || 1;
      }
      phasesCompleted += r.phases_completed;
      totalTokens += r.token_usage?.total_tokens || 0;
      totalDuration += r.total_duration_seconds || 0;
      if (r.timestamp && r.timestamp > latestTimestamp) latestTimestamp = r.timestamp;
    }

    const passRate = totalTasks > 0 ? tasksPassed / totalTasks : 0;
    const phaseRate = totalPhasesAll > 0 ? phasesCompleted / totalPhasesAll : 0;
    const weightedRate = maxWeightedScore > 0 ? weightedScore / maxWeightedScore : 0;
    const incomplete = tasksTested < totalTasks;

    rows.push({
      model, tasksTested, tasksPassed, totalTasks, passRate,
      phasesCompleted, totalPhasesAll, phaseRate,
      weightedScore, maxWeightedScore, weightedRate,
      totalTokens, totalDuration, incomplete, latestTimestamp
    });
  }

  if (summarySort === 'recent') {
    rows.sort((a, b) => b.latestTimestamp.localeCompare(a.latestTimestamp));
  } else {
    rows.sort((a, b) => b.weightedRate - a.weightedRate || b.phasesCompleted - a.phasesCompleted);
  }

  let html = `<table>
    <thead><tr>
      <th>Model</th>
      <th class="cell-num">Weighted Score</th>
      <th class="cell-num">Tasks Passed</th>
      <th class="cell-num">Pass Rate</th>
      <th class="cell-num">Phases Done</th>
      <th class="cell-num">Phase Rate</th>
      <th class="cell-num">Tokens</th>
      <th class="cell-num">Duration</th>
    </tr></thead><tbody>`;

  for (const r of rows) {
    const star = r.incomplete ? ' *' : '';
    html += `<tr>
      <td>${r.model}${star}</td>
      <td class="cell-num">${fmtPct(r.weightedRate)} ${progressBar(r.weightedRate)}</td>
      <td class="cell-num">${r.tasksPassed} / ${r.totalTasks}</td>
      <td class="cell-num">${fmtPct(r.passRate)}</td>
      <td class="cell-num">${r.phasesCompleted} / ${r.totalPhasesAll}</td>
      <td class="cell-num">${fmtPct(r.phaseRate)}</td>
      <td class="cell-num">${fmtTokens(r.totalTokens)}</td>
      <td class="cell-num">${fmtDuration(r.totalDuration)}</td>
    </tr>`;
  }

  html += '</tbody></table>';

  const incompleteModels = rows.filter(r => r.incomplete).map(r => r.model);
  if (incompleteModels.length > 0) {
    html += `<div class="footnote">* Not all tasks tested yet: ${incompleteModels.join(', ')}</div>`;
  }
  html += `<div class="footnote">Weighted score: easy\u00d71, medium\u00d73, hard\u00d75</div>`;

  document.getElementById('summaryBadge').textContent = `${rows.length} models`;
  document.getElementById('summaryTable').innerHTML = html;
}

// ── Render: Pass/Fail Matrix ─────────────────────────────

function renderMatrix(data) {
  const lookup = buildLookup(data);

  let html = `<table><thead><tr>
    <th>#</th><th>Task</th><th>Diff.</th><th>Phases</th>`;

  for (const m of data.models) {
    html += `<th style="text-align:center">${m}</th>`;
  }
  html += '</tr></thead><tbody>';

  for (const task of data.tasks) {
    const idx = task.task_id.replace('task_', '');
    html += `<tr>
      <td>${idx}</td>
      <td>${task.task_name}</td>
      <td class="${diffClass(task.difficulty)}">${task.difficulty}</td>
      <td class="cell-num">${task.total_phases}</td>`;

    for (const m of data.models) {
      const run = lookup[m]?.[task.task_id];
      html += statusCell(run, task.total_phases);
    }
    html += '</tr>';
  }

  html += '</tbody></table>';

  document.getElementById('matrixBadge').textContent = `${data.tasks.length} tasks x ${data.models.length} models`;
  document.getElementById('matrixTable').innerHTML = html;
}

// ── Render: By Difficulty ────────────────────────────────

function renderDifficulty(data) {
  const lookup = buildLookup(data);
  const difficulties = ['easy', 'medium', 'hard'];

  // Group tasks by difficulty
  const tasksByDiff = {};
  for (const d of difficulties) tasksByDiff[d] = [];
  for (const t of data.tasks) {
    const d = (t.difficulty || 'easy').toLowerCase();
    if (tasksByDiff[d]) tasksByDiff[d].push(t);
  }

  let html = `<table><thead><tr>
    <th>Difficulty</th><th>Tasks</th>`;

  for (const m of data.models) {
    html += `<th style="text-align:center">${m}</th>`;
  }
  html += '</tr></thead><tbody>';

  for (const diff of difficulties) {
    const tasks = tasksByDiff[diff];
    if (tasks.length === 0) continue;

    html += `<tr>
      <td class="${diffClass(diff)}" style="font-weight:600;text-transform:capitalize">${diff}</td>
      <td class="cell-num">${tasks.length}</td>`;

    for (const m of data.models) {
      const modelRuns = lookup[m] || {};
      let tested = 0;
      let passed = 0;
      for (const t of tasks) {
        const run = modelRuns[t.task_id];
        if (run) {
          tested++;
          if (run.final_status === 'completed') passed++;
        }
      }

      if (tested === 0) {
        html += '<td class="cell-na">—</td>';
      } else {
        const pct = fmtPct(passed / tasks.length);
        const partial = tested < tasks.length ? ' *' : '';
        const cls = passed === tasks.length ? 'cell-pass' :
                    passed === 0 ? 'cell-fail' : 'cell-error';
        html += `<td class="${cls}">${passed}/${tasks.length} (${pct})${partial}</td>`;
      }
    }
    html += '</tr>';
  }

  html += '</tbody></table>';
  html += '<div class="footnote">* Model has not been tested on all tasks in this difficulty group</div>';

  document.getElementById('diffBadge').textContent = `${data.models.length} models`;
  document.getElementById('difficultyTable').innerHTML = html;
}

// ── Poll Loop ────────────────────────────────────────────

async function fetchAndRender() {
  try {
    const resp = await fetch('/api/results');
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    const data = await resp.json();
    lastData = data;

    renderSummary(data);
    renderMatrix(data);
    renderDifficulty(data);

    const now = new Date();
    const ts = now.toLocaleTimeString();
    document.getElementById('statusText').textContent = `Updated ${ts}`;
    document.getElementById('statusDot').classList.remove('error');
  } catch (err) {
    document.getElementById('statusText').textContent = `Error: ${err.message}`;
    document.getElementById('statusDot').classList.add('error');
  }
}

// Initial fetch + interval
fetchAndRender();
setInterval(fetchAndRender, POLL_INTERVAL);
</script>

</body>
</html>
